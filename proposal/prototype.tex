\section{Experimental study: Quoting library}\label{sec:prototype}

For this thesis we will be using quoting in Agda.
We know that the quoting mechanism can be hard to work with, and is
incomplete in some ways.
The quoting mechanism is not well documented and published literature
does not teach us everything there is to know about it.
For this reason, and to get some concrete experience with generic
programming in Agda, we have built a prototype for a quoting library.

The main purpose of the prototype is to be able to fully automatically
generate a description and embedding-projection pair for a given data
type.

\subsection{Context-free types with a single fix point}

To keep things simple, we have chosen a fairly simple universe for
context-free types with a single fix
point\definedin{ContextFree.One.Desc}.
We described this universe in section \ref{sec:cft-single}.

The code should generate three functions; one which gives the
description within the universe, and two functions which convert
values between the original data type and the interpretation of the
description, commonly referred to as an embedding-projection pair.

\begin{verbatim}
desc : Desc
to : A → μ desc
from : μ desc → A
\end{verbatim}

The implementation is correct if \texttt{to} and \texttt{from} are
inverses of each other.

\begin{verbatim}
to-from : ∀ x → from (to x) ≡ x
from-to : ∀ x → to (from x) ≡ x
\end{verbatim}

\subsubsection[Example for natural numbers]
  {Example for natural numbers\definedin{ContextFree.One.Examples.Nat}}

We will first show how we can manually define \texttt{desc},
\texttt{to} and \texttt{from} for some examples.
The definitions are picked carefully to have a very predictable
structure, so we can generate these automatically later on.

Natural numbers have two constructors, zero and suc, the first has no
arguments and the latter has one recursive position.
In Agda we would define them with a data type:

\begin{verbatim}
data ℕ : Set where
  zero : ℕ
  suc : ℕ → ℕ
\end{verbatim}

We can also express them as $Nat = μX. 1 + x$.
The products can be terminated with a $1$ and we the sums with $0$.
Removing the $μ$, which is implicit in our universe, gives the
following definition:

\begin{verbatim}
desc = `1 `+ (`var `* `1) `+ `0
\end{verbatim}

Some definitions will have more clauses, and we will have some
additional unit (\texttt{⊤}) values due to the extra \texttt{`1}'s and
\texttt{`0}'s, but the more regular structure makes the code
generation much easier.

The definitions of \texttt{to} and \texttt{from} are fairly
straightforward:

\begin{verbatim}
to : ℕ → μ desc
to zero = ⟨ inj₁ tt ⟩
to (suc n) = ⟨ inj₂ (inj₁ (to n , tt)) ⟩

from : μ desc → ℕ
from ⟨ inj₁ tt ⟩ = zero
from ⟨ inj₂ (inj₁ (n , tt)) ⟩ = suc (from n)
from ⟨ inj₂ (inj₂ ()) ⟩
\end{verbatim}

It is easy to prove that \texttt{to} and \texttt{from} are inverses of
each other.
Those proofs are omitted here, as they are not very interesting.

\subsubsection[Example for lists]
  {Example for lists\definedin{ContextFree.One.Examples.List}}

We will take a look at how lists are embedded in our universe.
They have a type parameter, which we have to take care of.

\begin{verbatim}
data List (A : Set) : Set where
  [] : List A
  _∷_ : A → List A → List A
\end{verbatim}

The type parameter \texttt{A} has to be available in every function so we change
the types accordingly by adding \texttt{(A : Set) →}\ \ in front of the
type of each.
With the \texttt{`K} constructor we can add a spot for values of type \texttt{A} to
the description.
Values of this type are simply passed through in the definitions of
the embedding-projection pair.

\begin{verbatim}
desc : (A : Set) → Desc
desc A = `1 `+ (`K A `* `var `* `1) `+ `0

to : (A : Set) → ListP A → μ (desc A)
to A [] = ⟨ inj₁ tt ⟩
to A (x ∷ xs) = ⟨ inj₂ (inj₁ (x , to A xs , tt)) ⟩

from : (A : Set) → μ (desc A) → ListP A
from A ⟨ inj₁ tt ⟩ = []
from A ⟨ inj₂ (inj₁ (x , xs , tt)) ⟩ = x ∷ from A xs
from A ⟨ inj₂ (inj₂ ()) ⟩
\end{verbatim}

\subsubsection{Structure of desc}

Given a data type in Agda, we want to mechanically derive the
definition of \texttt{desc}.
We will be using quoting to implement this, which is explained in
section \ref{sec:prototype-implementation}.

The descriptions as we have shown in the examples follow the
conventional sum-of-products style where each constructor becomes a
product and all the products are summed.
Recursive arguments like \texttt{MyDatatype p₁⋯pₙ} become
\texttt{`var}'s and parameter arguments like \texttt{A} become
\texttt{`K A}.

\subsubsection{Structure of embedding-projection pair}

There is a pretty symmetry between the patterns and terms of the
clauses in \texttt{from} and the terms and patterns (respectively) of
the clauses in \texttt{to}.
We will call this property \emph{to/from symmetry}.

\begin{definition}
An embedding-projection pair has \emph{to/from symmetry} when for each
constructor of the datatype the functions have clauses with the
following structure:

\begin{verbatim}
to p₁⋯pₙ (real x) = rep (to p₁⋯pₙ x)
from p₁⋯pₙ (rep y) = real (from p₁⋯pₙ y)
\end{verbatim}
\end{definition}

Here we use \texttt{real} and \texttt{rep} as code generation
functions, which can be used both in patterns and in terms.
In the remainder of this section we will omit the application of data
type parameters \texttt{p₁⋯pₙ} for clarity.
As an example, we can instantiate \texttt{real} and \texttt{rep} for
the \texttt{suc} constructor:

\begin{verbatim}
to (suc x) = ⟨ inj₂ (inj₁ (to x , tt)) ⟩
from ⟨ inj₂ (inj₁ (y , tt)) ⟩ = suc (from y)
\end{verbatim}

The to/from symmetry property has a degenerate case for constructors
without recursive arguments:

\begin{verbatim}
to real = rep      -- for example: to zero = ⟨ inj₁ tt ⟩
from rep = real    -- for example: from ⟨ inj₁ tt ⟩ = zero
\end{verbatim}

\begin{theorem}
When an embedding-projection pair has to/from symmetry, \texttt{from}
and \texttt{to} are each others inverses.
\end{theorem}
\begin{proof}
The degenerate case is trivial:

\begin{verbatim}
to (from rep) ≡ to real ≡ rep
\end{verbatim}

To prove that \texttt{to (from (rep y)) ≡ rep y}, we can use induction
on \texttt{y} because it is structurally smaller than \texttt{rep y}.

\begin{verbatim} 
to (from (rep y))
  ≡ (definition of from)
to (real (from y))
  ≡ (definition of to)
rep (to (from y))
  ≡ (induction hypothesis: to (from y) ≡ y)
rep y
\end{verbatim}

A similar argument can be used to show that
\texttt{from (to (real x)) ≡ real x}.
\end{proof}

To fully define the embedding-projection pair, we only have to qive
suitable definitions for \texttt{real} and \texttt{rep}, and the
required properties of \texttt{to} and \texttt{from} will follow.

We give an imprecise definition of the code generation functions,
enough to convince the reader that mechanical construction is
possible:

\begin{verbatim}
real x = constructorᵢ args x args
rep x = ⟨ inj₂ⁱ (inj₁ (args , x , args , tt)) ⟩
\end{verbatim}

Where $i$ is a numerical identifier for the constructor, starting with
$i = 0$ for the first one, \texttt{inj₂ⁱ} is exactly $i$ applications
of \texttt{inj₂}.

\subsection{Implementation}\label{sec:prototype-implementation}

Up to this point we have not dived in to the nitty-gritty technical
details of the prototype quoting library.
The general structure is split in two parts:
\begin{enumerate}
\item Quoting the datatype to an intermediate representation.
\item Use the intermediate representation to generate the
  definitions of \texttt{desc}, \texttt{to} and \texttt{from}.
\end{enumerate}

The intermediate representation
\texttt{SafeDatatype}\definedin{ContextFree.One.Quoted} is chosen to
be safe in the sense that we can always generate function definitions
from it.
We have seen how we always generate descriptions in sum-of-products
style, so \texttt{SafeDatatype} is roughly the same as a list of lists
of arguments.
The name of the datatype and the name of each constructor is also
stored.

\begin{verbatim}
data SafeArg : Set where
  SK : (S : Term) → SafeArg
  Svar : SafeArg
SafeProduct = Name × List SafeArg
SafeSum = List SafeProduct
SafeDatatype = Name × Params × SafeSum
\end{verbatim}

To support data type parameters we include a list of types in
\texttt{Params}.
We allow the inclusion of raw quoted terms in \texttt{SK}, which might
refer to these parameters.
This introduces some uncertainty, because it may contain terms which
can not be represented by Desc.
Such problems will give type errors during the unquoting of the
definition of \texttt{desc}. \todo{Explain the problem}

\subsubsection[Quoting]{Quoting\definedin{ContextFree.One.Quoting}}

Agda supports quoting through a few built-in constructs.
There are primitives to get the type and definition of a given name:

\begin{verbatim}
type         : Name → Type
definition   : Name → Definition
\end{verbatim}

To use them, you need a \texttt{Name} which you can get with the
\texttt{quote} keyword.
A \texttt{Definition} can be anything which has a name, like
functions, data types, records or constructors.
If the definition gives us a data type, we can use 
\texttt{constructors : Data-type → List Name} to get a list of names
of the associated constructors.

Since there are so many ways the quoting process can fail, we have
defined an \texttt{Error}\definedin{Data.Error} type which supports
logging and failure (it's a list of messages and a Maybe).
\texttt{Error} is an applicative functor and a monad, so we can manage
the complexity quite well:

\begin{verbatim}
constructors <$> getDatatype (quote ListP)
 ≡ return (quote ListP.[] ∷ quote ListP._∷_ ∷ [])
\end{verbatim}

\todo{Explain why we have to pass the number of parameters}

\definedin{ContextFree.One.Quoting.Constructor}

quoteConstructor : Name → ⋯ → Error SafeProduct
quoteDatatype : Name → 

qdt : SafeDatatype
qdt = quoteDatatype! (quote ListP) 1

\subsubsection{Unquoting}

\todo[inline]{Prototype - Unquoting}
We can unquote a \texttt{SafeDatatype} us

makeDesc : SafeDatatype → FunctionDef
makeTo : (`to : Name) → (`desc : Name) → SafeDatatype → FunctionDef
makeFrom : (`from : Name) → (`desc : Name) → SafeDatatype → FunctionDef

unquoteDecl qdesc = makeDesc qdt
unquoteDecl qto = makeTo qto (quote qdesc) qdt
unquoteDecl qfrom = makeFrom qfrom (quote qdesc) qdt

\subsection{Results}\label{sec:prototype-results}

Propose changes:

SafeDatatype : Set
SafeDatatypeNames : SafeDatatype → Set
NamedSafeDatatype : Set = Σ SafeDatatype SafeDatatypeNames

DescFun : SafeDatatype → Set = p₁ → ⋯ → pₙ → Desc
descFun : (sd : SafeDatatype) → DescFun sd

makeTo : ⋯ → NamedSafeDatatype → FunctionDef
makeFrom : ⋯ → NamedSafeDatatype → FunctionDef

Make SafeDatatype truly safe by removing the Term's from it.

\todo[inline]{Prototype - Conclusion}


% \begin{tabular}{ l l l }
%  & Agda-code & \texttt{Desc} \\ \hline
% \multirow{2}{*}{⟦\_⟧arg} & \texttt{Self p₁⋯pₙ} & \texttt{`var} \\
% & \texttt{A} & \texttt{`K A} \\
% ⟦\_⟧prod & \texttt{a₁ → ⋯ → aₙ → Self p₁⋯pₙ}
%   & \texttt{⟦a₁⟧arg `* ⋯ `* ⟦aₙ⟧arg `* `1 } \\
% ⟦\_⟧sum & \vtop{
%   \hbox{\strut\texttt{data Self p₁⋯pₙ : Set where}}
%   \hbox{\strut\texttt{\ \ Con₁ : t₁}}
%   \hbox{\strut\texttt{\ \ \ \ }⋮}
%   \hbox{\strut\texttt{\ \ Conₙ : tₙ}}
% } & \texttt{⟦t₁⟧prod `+ ⋯ `+ ⟦tₙ⟧prod `+ `0}\\
% \end{tabular}
